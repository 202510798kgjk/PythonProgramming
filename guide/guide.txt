[학습 자료: 파이썬 프로그래밍 핵심 개념]

1. 프로그래밍 패러다임 및 파일 시스템 기본 개념
1-1. 프로그래밍 패러다임
    1-1-1. 절차지향 프로그래밍: 데이터를 중심으로 함수들을 정의하여 순차적인 절차에 따라 프로그램을 작성하는 방식입니다. 데이터와 처리 로직이 분리되어 있습니다.
    1-1-2. 객체지향 프로그래밍: 실제 세계의 사물을 객체로 모델링하여 프로그램을 작성하는 방식입니다. 데이터(속성)와 데이터를 처리하는 함수(행위/메서드)를 하나의 객체 안에 묶어 관리합니다. 재사용성, 유지보수성, 확장성이 향상됩니다.
1-2. 데이터 파일 입출력의 필요성
    1-2-1. 컴퓨터가 처리한 데이터를 휘발성 기억장치(RAM)가 아닌 비휘발성 저장장치(하드디스크, SSD 등)에 반영구적으로 저장하고, 필요할 때 다시 불러와 사용하기 위해 필요합니다. 이는 프로그램 종료 후에도 데이터를 유지하고, 대용량 데이터를 효율적으로 관리하기 위함입니다.
1-3. 파일 및 디렉터리 기본 개념
    1-3-1. 파일(File): 컴퓨터에서 데이터를 저장하는 논리적인 단위입니다. 일반적으로 특정 이름과 확장자를 가지며, 실행 파일, 데이터 파일 등 다양한 종류가 있습니다.
    1-3-2. 디렉터리(Directory): 파일을 효율적으로 관리하기 위해 파일들을 그룹화하여 저장하는 공간입니다. 폴더(Folder)라고도 불립니다.

2. 복합 자료형의 개념 및 리스트
2-1. 복합 자료형(Compound Data Type) 개념
    2-1-1. 여러 개의 데이터를 하나의 덩어리로 묶어서 관리하는 자료형입니다. 하나의 이름으로 다수의 데이터에 접근할 수 있게 하여 데이터 관리를 간단하고 명료하게 합니다.
2-2. 리스트(List) 개념 및 활용
    2-2-1. 개념: 여러 값을 순서대로 저장하는 변경 가능한(mutable) 복합 자료형입니다. `[]` 대괄호를 사용하여 선언합니다.
    2-2-2. 생성 및 초기화
        - `my_list = []` (빈 리스트)
        - `numbers = [1, 2, 3]`
        - `mixed = [1, 'hello', True]`
    2-2-3. 요소 접근
        - 인덱싱(Indexing): 리스트 내의 특정 위치(인덱스)의 요소에 접근합니다. 인덱스는 0부터 시작합니다. `my_list[0]`
        - 슬라이싱(Slicing): 리스트의 특정 범위의 요소들을 새로운 리스트로 추출합니다. `my_list[start:end:step]`
    2-2-4. 요소 수정: `my_list[index] = new_value`
    2-2-5. 요소 삭제
        - `del my_list[index]` (인덱스를 이용한 삭제)
        - `my_list.remove(value)` (값으로 첫 번째 일치하는 요소 삭제)
        - `my_list.pop(index)` (인덱스 위치의 요소를 삭제하고 반환, 인덱스 생략 시 마지막 요소)
        - `my_list.clear()` (모든 요소 삭제)
    2-2-6. 복사
        - 얕은 복사(Shallow Copy): 원본 리스트의 참조만 복사하여, 한쪽을 변경하면 다른 쪽도 영향을 받습니다. `new_list = old_list`
        - 깊은 복사(Deep Copy): 원본 리스트의 모든 요소를 재귀적으로 복사하여 완전히 독립적인 새로운 리스트를 생성합니다. `new_list = old_list[:]` 또는 `import copy; new_list = copy.deepcopy(old_list)`
    2-2-7. 연결 연산: `+` 연산자를 사용하여 두 개 이상의 리스트를 연결합니다. `list1 + list2`
    2-2-8. 비교 연산: `==`, `!=`, `<`, `>` 등 연산자를 사용하여 리스트의 내용을 비교합니다.
    2-2-9. 주요 메서드
        - `len(list)`: 리스트의 요소 개수를 반환합니다.
        - `list.append(item)`: 리스트의 끝에 요소를 추가합니다.
        - `list.insert(index, item)`: 특정 인덱스에 요소를 삽입합니다.
        - `list.index(value)`: 특정 값의 첫 번째 인덱스를 반환합니다.
        - `list.count(value)`: 특정 값의 개수를 반환합니다.
        - `value in list` / `value not in list`: 값이 리스트에 존재하는지 여부를 확인합니다.

3. 튜플 및 딕셔너리
3-1. 튜플(Tuple) 개념 및 활용
    3-1-1. 개념: 여러 값을 순서대로 저장하는 변경 불가능한(immutable) 복합 자료형입니다. `()` 소괄호를 사용하여 선언합니다.
    3-1-2. 생성: `my_tuple = (1, 2, 3)`
    3-1-3. 불변성 특징: 생성된 후에는 요소를 추가, 수정, 삭제할 수 없습니다. (리스트와 가장 큰 차이점)
    3-1-4. 요소 접근 (인덱싱, 슬라이싱), 연결 연산 (`+`)은 리스트와 동일하게 사용 가능합니다.
3-2. 딕셔너리(Dictionary) 개념 및 활용
    3-2-1. 개념: `키(key)`와 `값(value)`의 쌍으로 데이터를 저장하는 변경 가능한(mutable) 복합 자료형입니다. 순서가 없습니다. `{}` 중괄호를 사용하여 선언합니다.
    3-2-2. 키-값 쌍 구조: 각 요소는 고유한 키와 해당 키에 연결된 값으로 구성됩니다. 키는 변경 불가능해야 합니다 (예: 문자열, 숫자, 튜플).
    3-2-3. 생성: `my_dict = {'name': 'Alice', 'age': 30}`
    3-2-4. 요소 접근
        - `my_dict[key]` (키를 이용한 접근)
        - `my_dict.get(key, default_value)` (키를 이용한 접근, 키가 없으면 `None` 또는 지정된 `default_value` 반환)
        - `key in my_dict`: 키가 딕셔너리에 존재하는지 여부를 확인합니다.
    3-2-5. 요소 추가: `my_dict[new_key] = new_value`
    3-2-6. 요소 수정: `my_dict[existing_key] = new_value`
    3-2-7. 요소 삭제
        - `del my_dict[key]` (키를 이용한 삭제)
        - `my_dict.pop(key, default_value)` (키에 해당하는 값을 삭제하고 반환)
        - `my_dict.clear()` (모든 요소 삭제)

4. 복합 자료형과 반복문 및 함수 연동
4-1. 리스트와 반복문의 연동
    4-1-1. for 문 직접 반복: `for item in my_list:` (리스트의 각 요소를 직접 순회)
    4-1-2. 인덱스를 이용한 반복: `for i in range(len(my_list)):` (인덱스를 생성하여 리스트의 요소에 접근)
4-2. 이중 리스트의 개념 및 활용
    4-2-1. 개념: 리스트 안에 또 다른 리스트가 요소로 포함된 형태입니다. 행과 열을 가진 2차원 데이터를 표현할 때 주로 사용됩니다.
    4-2-2. 활용: 중첩된 반복문(for 문)을 사용하여 이중 리스트의 모든 요소에 접근할 수 있습니다.
4-3. 딕셔너리와 반복문의 연동
    4-3-1. 키 반복: `for key in my_dict:` (기본적으로 키를 순회)
    4-3-2. `keys()` 메서드: `for key in my_dict.keys():` (딕셔너리의 모든 키를 순회)
    4-3-3. `values()` 메서드: `for value in my_dict.values():` (딕셔너리의 모든 값을 순회)
    4-3-4. `items()` 메서드: `for key, value in my_dict.items():` (딕셔너리의 키와 값을 쌍으로 순회)
4-4. 복합 자료형을 함수에 전달 및 반환
    4-4-1. 리스트, 튜플, 딕셔너리 등의 복합 자료형은 함수의 매개변수로 전달될 수 있으며, 함수에서 이들을 반환할 수도 있습니다. 파이썬에서는 복합 자료형을 함수에 전달할 때 참조(주소)가 전달되어, 함수 내에서 원본을 변경하면 외부에도 영향을 미칩니다.

5. 클래스와 객체 기본 개념
5-1. 클래스(Class) 개념 및 정의
    5-1-1. 개념: 객체를 생성하기 위한 틀, 설계도, 또는 템플릿입니다. 객체들이 공통적으로 가지는 속성(데이터)과 행위(메서드)를 정의합니다.
    5-1-2. 정의: `class ClassName:` 키워드를 사용하여 정의하며, 그 안에 속성과 메서드를 포함합니다.
5-2. 객체(Object) 개념 및 클래스와의 관계
    5-2-1. 개념: 클래스로부터 생성된 실제 인스턴스(instance)입니다. 클래스라는 설계도에 따라 만들어진 '실체'입니다.
    5-2-2. 관계: 클래스는 추상적인 개념이고, 객체는 그 클래스의 구체적인 구현체입니다. 하나의 클래스에서 여러 개의 객체를 생성할 수 있습니다.
5-3. 객체의 속성 및 행위 구성
    5-3-1. 속성(Attribute): 객체가 가지는 데이터(변수)입니다. 객체의 현재 상태를 나타냅니다.
    5-3-2. 행위(Behavior) / 메서드(Method): 객체가 수행할 수 있는 동작(함수)입니다. 속성을 조작하거나 특정 기능을 수행합니다.
5-4. 객체 생성 및 속성 접근
    5-4-1. 객체 생성: `object_name = ClassName()` 형태로 클래스를 호출하여 객체를 생성합니다.
    5-4-2. 속성 접근: `object_name.attribute_name` 형태로 객체의 속성에 접근하고 값을 할당하거나 읽을 수 있습니다.
    5-4-3. 메서드 내에서 자신의 속성에 접근: 메서드 정의 시 첫 번째 매개변수로 `self`를 사용하여 현재 객체 자신을 참조하고, `self.attribute_name` 형태로 자신의 속성에 접근합니다.

6. 객체지향 심화 개념 (생성자, 정보 은닉, 클래스 단위 멤버)
6-1. 생성자(Constructor) 개념 및 역할
    6-1-1. 개념: 객체가 생성될 때 자동으로 호출되어 객체의 초기 상태(속성 값)를 설정하는 특별한 메서드입니다. 파이썬에서는 `__init__` 메서드로 정의합니다.
    6-1-2. 역할: 객체를 사용 가능한 상태로 초기화하고, 필수적인 속성 값들을 설정하여 객체의 일관성을 유지하는 데 사용됩니다.
6-2. 정보 은닉(Information Hiding)
    6-2-1. 개념: 객체의 내부 구현(속성)을 외부로부터 숨기고, 미리 정의된 메서드(행위)를 통해서만 접근하도록 하는 객체지향의 원칙입니다. 이를 통해 객체의 무결성을 보호하고 코드의 변경이 미치는 영향을 최소화합니다.
    6-2-2. 비공개 속성: 속성 이름 앞에 `__` (더블 언더스코어)를 붙여 비공개(private) 속성으로 간주합니다. 직접적인 외부 접근을 막습니다. (내부적으로 이름 변환이 일어남)
    6-2-3. 액세스 메서드 (게터/세터): 비공개 속성에 안전하게 접근하고 값을 변경할 수 있도록 제공하는 공개(public) 메서드입니다.
        - 게터(Getter): 비공개 속성의 값을 반환하는 메서드입니다.
        - 세터(Setter): 비공개 속성의 값을 설정하는 메서드입니다.
6-3. 클래스 단위 멤버
    6-3-1. 클래스 변수(Class Variable): 클래스 자체에 속하는 변수로, 해당 클래스로부터 생성된 모든 객체가 공유합니다. 클래스 이름으로 직접 접근하거나 객체 이름으로도 접근할 수 있습니다.
    6-3-2. 정적 메서드(Static Method): 객체의 특정 속성에 의존하지 않고 독립적인 기능을 수행하는 메서드입니다. `@staticmethod` 데코레이터를 사용하여 정의하며, `self`나 `cls` 매개변수를 가지지 않습니다. 클래스 이름으로 직접 호출합니다.
    6-3-3. 클래스 메서드(Class Method): 클래스 자체에 바인딩된 메서드로, 객체 인스턴스가 아닌 클래스 자체를 조작할 때 사용됩니다. `@classmethod` 데코레이터를 사용하여 정의하며, 첫 번째 매개변수로 클래스 자신을 나타내는 `cls`를 받습니다. 주로 대체 생성자(alternative constructor)나 클래스 변수에 접근/수정할 때 활용됩니다.

7. 데이터 파일 구성 및 처리 기본
7-1. 데이터 파일의 두 가지 구성 방법
    7-1-1. 이진 파일(Binary File): 데이터를 컴퓨터가 이해하는 이진(바이너리) 형식으로 저장하는 파일입니다. 텍스트 에디터로 열면 내용을 알아보기 어렵습니다. 이미지, 오디오, 비디오, 실행 파일 등이 이에 해당합니다. 저장 및 읽기 속도가 빠르고, 더 적은 저장 공간을 차지할 수 있습니다.
    7-1-2. 텍스트 파일(Text File): 데이터를 사람이 읽을 수 있는 문자열 형태로 저장하는 파일입니다. 텍스트 에디터로 열면 내용을 직접 확인할 수 있습니다. `.txt`, `.py`, `.html` 파일 등이 이에 해당합니다.
7-2. 파일 열기 및 닫기
    7-2-1. 파일 열기(`open()` 함수): 파일을 읽거나 쓰기 위해 `open()` 함수를 사용하여 파일을 엽니다. `file_object = open(filename, mode, encoding)`
    7-2-2. 파일 닫기(`close()` 메서드): 파일 작업을 마친 후에는 반드시 `close()` 메서드를 사용하여 파일을 닫아야 합니다. 이는 시스템 자원을 해제하고 버퍼에 남은 데이터를 파일에 확실히 쓰는 역할을 합니다.
7-3. 다양한 파일 열기 모드
    7-3-1. `'r'`: 읽기 모드 (기본값). 파일이 없으면 오류 발생.
    7-3-2. `'w'`: 쓰기 모드. 파일이 없으면 새로 생성하고, 있으면 기존 내용을 모두 지우고 덮어씁니다.
    7-3-3. `'a'`: 추가(append) 모드. 파일이 없으면 새로 생성하고, 있으면 파일의 끝에 내용을 추가합니다.
    7-3-4. `'b'`: 이진 모드 (예: `rb`, `wb`, `ab`).
    7-3-5. `'t'`: 텍스트 모드 (기본값).
    7-3-6. `'+'`: 읽기/쓰기 모드 (예: `r+`, `w+`, `a+`).
7-4. `with` 키워드를 사용한 안전한 파일 처리
    7-4-1. `with open(filename, mode) as file_object:` 구문을 사용하면 파일 작업을 마친 후(또는 오류 발생 시) 파일을 자동으로 닫아줍니다. 이는 `close()`를 명시적으로 호출할 필요 없이 안전하게 파일을 처리하는 방법입니다.

8. 파일 입출력 심화 (텍스트, 이진 파일)
8-1. 텍스트 파일에 데이터 쓰고 읽기
    8-1-1. 쓰기
        - `file_object.write(string)`: 문자열을 파일에 씁니다. 줄바꿈은 직접 `\n`을 추가해야 합니다.
        - `file_object.writelines(list_of_strings)`: 문자열 리스트의 각 문자열을 파일에 씁니다.
    8-1-2. 읽기
        - `file_object.read()`: 파일의 전체 내용을 하나의 문자열로 읽어옵니다.
        - `file_object.readline()`: 파일에서 한 줄을 읽어옵니다.
        - `file_object.readlines()`: 파일의 모든 줄을 읽어와 각 줄을 요소로 하는 리스트로 반환합니다.
    8-1-3. 인코딩(Encoding): 문자를 컴퓨터가 저장하고 처리할 수 있는 형태로 변환하는 방식입니다. 파일을 열 때 `encoding='utf-8'` 또는 `encoding='euc-kr'`과 같이 인코딩 방식을 지정해야 한글 깨짐 현상을 방지할 수 있습니다.
8-2. `pickle` 모듈을 이용한 이진 파일 입출력
    8-2-1. 개념: 파이썬 객체를 직렬화(serialization)하여 이진 파일로 저장하고, 역직렬화(deserialization)하여 다시 파이썬 객체로 불러오는 기능을 제공하는 모듈입니다.
    8-2-2. 직렬화(Pickling): 파이썬 객체를 바이트 스트림으로 변환하여 파일에 저장하는 과정입니다. `pickle.dump(object, file_object)`
    8-2-3. 역직렬화(Unpickling): 바이트 스트림으로 저장된 데이터를 다시 파이썬 객체로 복원하는 과정입니다. `pickle.load(file_object)`
    8-2-4. 사용자 정의 클래스 객체의 입출력: `pickle` 모듈은 사용자 정의 클래스의 객체도 직렬화/역직렬화하여 파일로 저장하고 불러올 수 있습니다.

9. GUI 프로그래밍 기본 개념 (tkinter)
9-1. GUI 프로그래밍의 개념
    9-1-1. GUI(Graphical User Interface): 사용자가 그래픽 요소를 통해 컴퓨터와 상호작용할 수 있도록 하는 사용자 인터페이스입니다. 버튼, 메뉴, 아이콘, 윈도우 등의 시각적 요소로 구성됩니다.
    9-1-2. 이벤트 기반 프로그래밍(Event-Driven Programming): 프로그램의 흐름이 사용자(또는 시스템)의 특정 '이벤트' 발생에 의해 결정되는 프로그래밍 방식입니다. 이벤트(예: 버튼 클릭, 키 입력, 마우스 이동)가 발생하면, 해당 이벤트에 연결된 특정 함수(이벤트 핸들러)가 호출되어 처리됩니다. 이는 GUI 프로그램의 핵심 동작 방식입니다.
9-2. `tkinter` 모듈의 활용
    9-2-1. 파이썬 표준 라이브러리에 포함된 GUI 툴킷으로, 간단하고 빠르게 GUI 애플리케이션을 개발할 수 있도록 도와줍니다.
9-3. 루트 윈도우의 기본 구성
    9-3-1. 생성: `tk.Tk()`를 호출하여 최상위 윈도우(루트 윈도우)를 생성합니다. `root = tk.Tk()`
    9-3-2. 제목 설정: `root.title("윈도우 제목")` 메서드를 사용하여 윈도우 제목 표시줄의 텍스트를 설정합니다.
    9-3-3. 크기/위치 설정: `root.geometry("너비x높이+x좌표+y좌표")` 메서드를 사용하여 윈도우의 크기와 화면 상의 초기 위치를 설정합니다.
    9-3-4. 크기 고정: `root.resizable(width=False, height=False)` 메서드를 사용하여 사용자가 윈도우의 크기를 조절할 수 없도록 고정할 수 있습니다.
    9-3-5. 메인 루프: `root.mainloop()`를 호출하여 GUI 이벤트를 지속적으로 처리하고 윈도우를 화면에 표시합니다. 이 함수는 이벤트가 발생하기를 기다리며, 이벤트가 발생하면 해당 이벤트 핸들러를 호출합니다.
9-4. `tk변수 객체` (StringVar, IntVar, DoubleVar, BooleanVar)의 개념과 역할
    9-4-1. 개념: `tkinter` 위젯과 파이썬 변수 사이의 데이터 바인딩을 가능하게 하는 특별한 유형의 변수 객체입니다. 위젯에 표시되는 값과 파이썬 코드 내의 변수 값을 동기화하는 데 사용됩니다.
    9-4-2. 역할: `Entry`, `Label`, `Checkbutton`, `Radiobutton` 등 다양한 위젯의 `textvariable`, `variable` 옵션에 연결하여 위젯의 값을 쉽게 읽고(`get()`) 쓸 수(`set()`) 있도록 합니다. 이를 통해 데이터 입력 및 출력, 위젯 상태 관리가 간편해집니다.
9-5. 기본 위젯의 종류와 역할
    9-5-1. 위젯(Widget): GUI 애플리케이션을 구성하는 그래픽 사용자 인터페이스 요소들입니다. 버튼, 레이블, 텍스트 상자, 체크박스 등이 있습니다.
    9-5-2. 주요 위젯
        - `Label`: 텍스트나 이미지를 표시합니다.
        - `Button`: 클릭 시 특정 동작을 수행합니다.
        - `Entry`: 한 줄 텍스트 입력을 받습니다.
        - `Text` / `ScrolledText`: 여러 줄 텍스트 입력을 받거나 표시합니다.
        - `Checkbutton`: 체크박스 형태로, 켜거나 끌 수 있는 상태를 나타냅니다.
        - `Radiobutton`: 여러 옵션 중 하나만 선택할 수 있도록 합니다.
9-6. 위젯 배치 방법
    9-6-1. `pack()` 메서드: 위젯을 컨테이너 내부에 블록 형태로 배치합니다. `side`, `fill`, `expand`, `padx`, `pady`, `ipadx`, `ipady` 등의 옵션으로 배치를 조절합니다.
    9-6-2. `grid()` 메서드: 위젯을 테이블(그리드) 형태로 행과 열에 맞춰 배치합니다. `row`, `column`, `rowspan`, `columnspan`, `sticky` 등의 옵션을 사용합니다.
    9-6-3. `Frame` 위젯 활용: 여러 위젯을 그룹화하여 배치하기 위한 컨테이너 역할을 하는 위젯입니다. 복잡한 GUI 레이아웃을 구성할 때 유용합니다.
9-7. 객체지향적 GUI 구성의 개념
    9-7-1. GUI 프로그램을 절차 지향적으로 작성하면 코드가 복잡해지고 전역 변수 사용이 많아져 유지보수가 어려워질 수 있습니다. 객체지향적으로 GUI를 구성한다는 것은, 각 윈도우나 특정 화면 섹션을 클래스로 만들고, 각 클래스 안에 해당 화면의 위젯들과 이벤트 처리 로직을 캡슐화하는 것을 의미합니다. 이를 통해 코드의 모듈성과 재사용성이 향상되고, 대규모 GUI 애플리케이션 개발에 유리합니다.
